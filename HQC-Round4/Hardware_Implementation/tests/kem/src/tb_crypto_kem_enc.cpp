/**
 * @file tb_crypto_kem_en.cpp
 * @brief Calls the kem encapsulation function and checks the encapsulation output the same as the one generated by the reference code.
 */

#include "kem.h"
#include <string.h>

int tb_generic_call(void (*f)(uint8_t*, size_t), const char *name, size_t compare_bytesize);

/**
 * @brief Calls the encapsulation function and writes the result of the encapsulation in hex into output.
 *
 * Initialises the PRNG with 0x43 as initial entropy byte, generates a keypair, increases the prng seed to 0x44, calls
 * crypto_kem_enc_internal and writes the resulting shared secret in encapsulated and plaintext form in hex into output.
 *
 * @param[out] output pointer to a byte array containing a shared secret in encapsulated and plaintext form in hex
 * @param[in] compare_bytesize amount of bytes that will be compared with the reference data, unused here.
 */
void tested_function(uint8_t *output, size_t compare_bytesize) {
    ap_uint64 pk[PUBLIC_KEY_64BIT_SIZE] = {0};
    ap_uint64 sk[SECRET_KEY_64BIT_SIZE] = {0};
    ap_uint64 ss[SHARED_SECRET_64BIT_SIZE] = {0};
    ap_uint8 ct[CRYPTO_CIPHERTEXTBYTESIZE] = {0};
    ap_uint8 entropy[1] = {0x43};

    crypto_kem_keypair_hls(pk, sk, entropy, 1);
    entropy[0]+=1;
    crypto_kem_enc_hls(ct, ss, pk, entropy, 1);

    memcpy((void *)output, (void *)ct, CRYPTO_CIPHERTEXTBYTESIZE);
    memcpy((void *)&output[CRYPTO_CIPHERTEXTBYTESIZE], (void *)ss, CRYPTO_SHARED_SECRET_BYTESIZE);

}

/**
 * @brief Launches the tb_generic_call function that calls tested_function and checks the resulting output is correct.
 *
 * Calls the generic function that will call tested_function to generate the hardware implementation output,
 * and then compare this output to the reference data which is available on a pre-generated file.
 *
 * @returns 0 if the outputs are the same and 1 if not
 */
int main() {
    const char *test_name = "crypto_kem_enc";
    return tb_generic_call(tested_function, test_name, CRYPTO_CIPHERTEXTBYTESIZE + CRYPTO_SHARED_SECRET_BYTESIZE);
}

