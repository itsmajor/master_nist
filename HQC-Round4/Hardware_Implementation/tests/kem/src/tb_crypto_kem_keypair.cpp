/**
 * @file tb_crypto_kem_keypair.cpp
 * @brief Generates a keypair and checks it is the same as the one generated by the reference code.
 */

#include "kem.h"
#include <string.h>

int tb_generic_call(void (*f)(uint8_t*, size_t), const char *name, size_t compare_bytesize);

/**
 * @brief Generates a keypair and writes it in hex into output.
 *
 * Initialises the PRNG with 0x43 as initial entropy byte, calls crypto_kem_keypair_internal and
 * writes the associated public and private keys in hex into output.
 *
 * @param[out] output pointer to a byte array containing the public and private key in hex
 * @param[in] compare_bytesize amount of bytes that will be compared with the reference data, unused here.
 */
void tested_function(uint8_t *output, size_t compare_bytesize) {
    ap_uint64 pk[PUBLIC_KEY_64BIT_SIZE] = {0};
    ap_uint64 sk[SECRET_KEY_64BIT_SIZE] = {0};
    ap_uint8 entropy[1] = {0x43};

    crypto_kem_keypair_hls(pk, sk, entropy, 1);

    memcpy((void *)output, (void *)pk, CRYPTO_PUBLICKEYBYTESIZE);
    memcpy((void *)&output[CRYPTO_PUBLICKEYBYTESIZE], (void *)sk, CRYPTO_SECRETKEYBYTESIZE);
}

/**
 * @brief Launches the tb_generic_call function that calls tested_function and checks the resulting output is correct.
 *
 * Calls the generic function that will call tested_function to generate the hardware implementation output,
 * and then compare this output to the reference data which is available on a pre-generated file.
 *
 * @returns 0 if the outputs are the same and 1 if not
 */
int main() {
    const char *test_name = "crypto_kem_keypair";
    return tb_generic_call(tested_function, test_name, CRYPTO_PUBLICKEYBYTESIZE + CRYPTO_SECRETKEYBYTESIZE);
}

