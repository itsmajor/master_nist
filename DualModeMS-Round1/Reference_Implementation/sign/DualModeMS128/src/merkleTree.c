#include "merkleTree.h"
#include "init.h"
#include "bit.h"

BEGIN_EXTERNC
    #include <libXKCP.a.headers/SimpleFIPS202.h>
END_EXTERNC


/*  Input: tree a Merkle tree with the initialized leaves, the ith leave is the 
           hash of the ith point P(zi)

    Output: tree a Merkle tree: each node is the hash of the both parents
            roots is every roots of the Merkle tree
*/
void merkleTreeMerge(unsigned char* roots, unsigned char* tree) 
{
    /* L_parent on the larger floor, L_children on the next floor */
    const unsigned char* L_parent=tree;
    unsigned char* L_children=tree+Tau*SIZE_DIGEST;
    unsigned int i;

    /* For each pair of parent node, creation of the children node */
    /* There are NB_NODE_WITHOUT_LEAVES children nodes */
    for(i=0;i<NB_NODE_WITHOUT_LEAVES;++i) 
    {
        /* the children node is the hash of the cat of their parents */
        HASH(L_children,L_parent,SIZE_2_DIGEST);
        L_parent+=SIZE_2_DIGEST;
        L_children+=SIZE_DIGEST;
    }

    /* For the roots */
    L_children=roots;
    for(i=0;i<TWO_POW_DELTA;++i) 
    {
        /* the children node is the hash of the cat of their parents */
        HASH(L_children,L_parent,SIZE_2_DIGEST);
        L_parent+=SIZE_2_DIGEST;
        L_children+=SIZE_DIGEST;
    }
}


/* Input: a Merkle tree and the index of a leave

   Output: path with all hash to be able to build a root with from the index-th
           leaves
*/
void merkleTreeOpenPath(UINT* path, const UINT* tree, unsigned int index) 
{
    const UINT *tree_cp=tree,*tree_cp2;
    UINT *path_cp=path;
    unsigned int i,val=index;

    for(i=0;i<LEN_PATH;++i) 
    {
        tree_cp2=tree_cp+(val^1U)*SIZE_DIGEST_UINT;
        val>>=1;
        COPYHASH(path_cp,tree_cp2);
        path_cp+=SIZE_DIGEST_UINT;
        tree_cp+=(Tau>>i)*SIZE_DIGEST_UINT;
    }
}


/* Input: hash_point the hash of the index-th points
          path the hash generated by merkleTreeOpenPath
          roots the roots of the Merkle tree

   Ouput: 0 if with hash_points and path, we obtain roots (success)
          != 0 else (fail)
*/
int merkleTreeVerify(const UINT* roots, UINT* hash_point, const UINT* path, \
                     unsigned int index) 
{
    UINT input_hash_left[SIZE_2_DIGEST>>3];
    UINT *input_hash_right=input_hash_left+SIZE_DIGEST_UINT;
    const UINT* path_cp=path;
    unsigned int i,val=index;

    for(i=0;i<LEN_PATH;++i) 
    {
        if(val&1)
        {
            COPYHASH(input_hash_left,path_cp);
            COPYHASH(input_hash_right,hash_point);
        } else
        {
            COPYHASH(input_hash_left,hash_point);
            COPYHASH(input_hash_right,path_cp);
        }
        val>>=1;
        path_cp+=SIZE_DIGEST_UINT;
        HASH((unsigned char*)hash_point,\
             (const unsigned char*)input_hash_left,SIZE_2_DIGEST);
    }
    return !EQUALHASH(roots+val*SIZE_DIGEST_UINT,hash_point);
}

